<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++协程：理解承诺类型 | 鲤鱼王的记录小宇宙</title><meta name="author" content="Ferocious Magikarp"><meta name="copyright" content="Ferocious Magikarp"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="原文来自 C++ Coroutines: Understanding the promise type。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++协程：理解承诺类型">
<meta property="og:url" content="https://ferociousmagikarp.github.io/posts/43da13b0/index.html">
<meta property="og:site_name" content="鲤鱼王的记录小宇宙">
<meta property="og:description" content="原文来自 C++ Coroutines: Understanding the promise type。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ferociousmagikarp.github.io/image/head.png">
<meta property="article:published_time" content="2024-07-13T11:39:33.000Z">
<meta property="article:modified_time" content="2024-07-13T11:39:33.000Z">
<meta property="article:author" content="Ferocious Magikarp">
<meta property="article:tag" content="计算机">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="协程">
<meta property="article:tag" content="博客翻译">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ferociousmagikarp.github.io/image/head.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C++协程：理解承诺类型",
  "url": "https://ferociousmagikarp.github.io/posts/43da13b0/",
  "image": "https://ferociousmagikarp.github.io/image/head.png",
  "datePublished": "2024-07-13T11:39:33.000Z",
  "dateModified": "2024-07-13T11:39:33.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Ferocious Magikarp",
      "url": "https://ferociousmagikarp.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/image/favicon.png"><link rel="canonical" href="https://ferociousmagikarp.github.io/posts/43da13b0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: false,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++协程：理解承诺类型',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/Kimbiedark.css"><meta name="generator" content="Hexo 7.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="web_bg" style="background-image: url(/image/galaxy.webp);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">鲤鱼王的记录小宇宙</span></a><a class="nav-page-title" href="/"><span class="site-name">C++协程：理解承诺类型</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C++协程：理解承诺类型</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-13T11:39:33.000Z" title="发表于 2024-07-13 19:39:33">2024-07-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-13T11:39:33.000Z" title="更新于 2024-07-13 19:39:33">2024-07-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>原文来自<a target="_blank" rel="noopener" href="https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type">C++ Coroutines: Understanding the promise type</a>。</p>
<p>这篇文章是 C++ Coroutines TS（<a target="_blank" rel="noopener" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4736.pdf">N4736</a>）系列文章的第三篇。</p>
<p>之前的文章有：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://lewissbaker.github.io/2017/09/25/coroutine-theory">coroutine-theory</a>，其中文翻译<a href="https://ferociousmagikarp.github.io/2024/04/19/cpp%E5%8D%8F%E7%A8%8B%E7%90%86%E8%AE%BA/">C++协程理论</a>；</li>
<li><a target="_blank" rel="noopener" href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">C++ Coroutines: Understanding operator co_await</a>，其中文翻译<a href="https://ferociousmagikarp.github.io/2024/06/17/cpp%E5%8D%8F%E7%A8%8B-%E7%90%86%E8%A7%A3co-await%E6%93%8D%E4%BD%9C/">C++协程：理解co_await操作</a>。</li>
</ul>
<p>在这篇文章中，我会探讨编译器将你编写的代码转换为协程代码的机制，以及如何通过定义你自己的<strong>承诺类型</strong>（Promise type）来定制协程的行为。</p>
<h2 id="协程概念">协程概念</h2>
<p>Coroutines TS 添加了三个新的关键字：<code>co_await</code>、<code>co_yield</code> 和 <code>co_return</code>。无论什么时候，只要你在函数体中使用了这三个关键字之一，就会让编译器将这个函数编译为协程而不是普通函数。</p>
<p>编译器会对你写的代码进行一些相当机械的转换，将其转换为一个状态机，会允许其在函数的某个特定点挂起执行，并在之后恢复。</p>
<p>在上一篇文章中我描述了 Coroutines TS 所提出的两个接口中的第一个：<strong>Awaitable</strong> 接口。TS 所提出的另一个接口对上述代码转换非常重要，那就是 <strong>Promise</strong> 接口。</p>
<p><strong>Promise</strong> 接口指定一些定制协程自身行为的方法。库编写者可以自定义协程调用的时候该干什么，协程返回的时候该干什么（包括普通的含义或未经处理的异常）以及定制协程里任何 <code>co_await</code> 或 <code>co_yield</code> 的行为。</p>
<h2 id="承诺对象-promise-objects">承诺对象（Promise objects）</h2>
<p><strong>承诺对象</strong>通过实现协程执行期间在某些特殊点上调用的方法，来定义和控制协程自身的行为。</p>
<blockquote>
<p>在我们继续之前，我想让你先摆脱任何有关“承诺”（Promise）的先入为主的观念。虽然在某些情况下，协程的承诺对象确实扮演了与 <code>std::future</code> 中 <code>std::promise</code> 相似的角色，但是在另外一些情况下，这个类比有些牵强。一个更容易的思考方式是将协程的一个承诺对象视为一个“协程状态控制器”对象，其可以用于控制协程行为，以及追踪协程状态。</p>
</blockquote>
<p>对于每次协程函数的调用，都会在协程帧中创建一个承诺对象的实例。</p>
<p>在协程执行过程中，编译器会在关键点生成对承诺对象的某些关键方法的调用。</p>
<p>在接下来的例子中，假定这个承诺对象为 <code>promise</code>，其创建于特定协程调用的协程帧中。</p>
<p>当你编写一个主体为 <code>&lt;body-statements&gt;</code> 的协程函数，其包含协程关键字之一（<code>co_return</code>, <code>co_await</code>, <code>co_yield</code>），那么这个协程的函数体会被转换为如下所示内容（大概）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">&#123;<br>  <span class="hljs-keyword">co_await</span> promise.<span class="hljs-built_in">initial_suspend</span>();<br>  <span class="hljs-keyword">try</span><br>  &#123;<br>    &lt;body-statements&gt;<br>  &#125;<br>  <span class="hljs-built_in">catch</span> (...)<br>  &#123;<br>    promise.<span class="hljs-built_in">unhandled_exception</span>();<br>  &#125;<br>FinalSuspend:<br>  <span class="hljs-keyword">co_await</span> promise.<span class="hljs-built_in">final_suspend</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当调用一个协程函数时，在执行协程体源代码之前会执行若干步骤，这些步骤于常规函数略有不同。</p>
<p>这是这些步骤的概要（我将在下文详述每个步骤）：</p>
<ol>
<li>使用 <code>operator new</code> 分配一个协程帧（可选的）。</li>
<li>复制任意函数参数到协程帧中。</li>
<li>调用类型为 <code>P</code> 的承诺对象的构造函数。</li>
<li>调用 <code>promise.get_return_object()</code> 方法来获取协程第一次挂起时返回给调用者的结果，把这个结果存储为局部变量。</li>
<li>调用 <code>promise.initial_suspend()</code> 方法并 <code>co_await</code> 这个结果。</li>
<li>当 <code>co_await promise.initial_suspend()</code> 表达式恢复时（不论是立即恢复还是异步恢复），协程就会开始执行你编写的协程体语句。</li>
</ol>
<p>当执行到达 <code>co_return</code> 语句时会执行一些额外步骤：</p>
<ol>
<li>调用 <code>promise.return_void()</code> 或 <code>promise.return_value(&lt;expr&gt;)</code>。</li>
<li>以与创建相反的顺序来销毁所有具有自动存储期的变量。</li>
<li>调用 <code>promise.final_suspend()</code> 并 <code>co_await</code> 结果。</li>
</ol>
<p>如果另一种情况，执行由于未处理的异常而离开 <code>&lt;body-statements&gt;</code>，那么：</p>
<ol>
<li>捕获异常并在捕获块内调用 <code>promise.unhandled_exception()</code>。</li>
<li>调用 <code>promise.final_suspend()</code> 并 <code>co_await</code> 结果。</li>
</ol>
<p>一旦执行传播到协程体外部，那么协程帧就会销毁。销毁协程帧包括以下一些步骤：</p>
<ol>
<li>调用承诺对象的析构函数。</li>
<li>调用函数参数拷贝的析构函数。</li>
<li>调用 <code>operator delete</code> 来释放协程帧使用的内存（可选）。</li>
<li>将执行转移回调用者/恢复器。</li>
</ol>
<p>当执行第一次到达 <code>co_await</code> 表达式中的 <code>&lt;return-to-caller-or-resumer&gt;</code> 点处，或者协程执行完成但没有命中 <code>&lt;return-to-caller-or-resumer&gt;</code> 点，那么协程要么挂起，要么销毁，然后之前从 <code>promise.get_return_object()</code> 中返回的对象就会返回给协程的调用者。</p>
<h3 id="分配协程帧">分配协程帧</h3>
<p>首先，编译器生成对 <code>operator new</code> 的调用来分配协程帧的内存。</p>
<p>如果这个承诺类型 <code>P</code> 有自定义的 <code>operator new</code> 方法，那么就调用它，否则就会调用全局的 <code>operator new</code>。</p>
<p>有一些重要的内容需要在这里注明：</p>
<p>传递给 <code>operator new</code> 的大小不是 <code>sizeof(P)</code>，而是整个协程帧的大小。这个大小由编译器自动决定，取决于参数的数量和大小、承诺对象的大小、局部变量的数量和大小，以及其它编译器指定的需要管理协程状态的存储空间。</p>
<p>如果下面的条件满足，那么编译器可以作为优化而省略对 <code>operator new</code> 的调用：</p>
<ul>
<li>可以确定协程帧的生命周期严格嵌套在调用者生命周期的范围内；</li>
<li>编译器可以在调用侧知道写城镇所需求的内存大小。</li>
</ul>
<p>在这几种情况下，编译器就可以将存储协程帧的内存分配在调用者的激活帧上（无论是在栈帧部分或者是在协程帧部分）。</p>
<p>Coroutines TS 还未指定在什么情况下保证消除分配内存，所以你仍然需要在写代码的时候考虑分配协程帧可能失败并抛出 <code>std::bad_alloc</code> 异常的情况。这也意味着你通常不能将一个协程函数声明为 <code>noexcept</code>，除非在协程分配协程帧内存失败时调用 <code>std::terminate</code> 你也无所谓。</p>
<p>但是，有一种替代方案可以在协程帧分配内存失败时使用，来代替抛出异常。在一些不允许抛出异常的环境中，比如嵌入式环境或者不能容忍异常开销的高性能环境，可能这样做是很有必要的。</p>
<p>如果承诺类型提供了静态的 <code>P::get_return_object_on_allocation_failure()</code> 成员函数，那么编译器就会转而生成对 <code>operator new(size_t, nothrow_t)</code> 重载的调用。如果这个调用返回 <code>nullptr</code>，那么协程会立即调用 <code>P::get_return_object_on_allocation_failure()</code> 并将结果返回给协程的调用者，而不是抛出异常。</p>
<h4 id="自定义协程帧内存分配">自定义协程帧内存分配</h4>
<p>你的承诺类型可以定义一个 <code>operator new()</code> 的重载，在编译器需要分配你的承诺类型所使用的协程帧内存时，来代替全局作用域的 <code>operator new</code> 进行调用。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">my_promise_type</span><br>&#123;<br>  <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-type">void</span>* ptr = <span class="hljs-built_in">my_custom_allocate</span>(size);<br>    <span class="hljs-keyword">if</span> (!ptr) <span class="hljs-keyword">throw</span> std::bad_alloc&#123;&#125;;<br>    <span class="hljs-keyword">return</span> ptr;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr, std::<span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">my_custom_free</span>(ptr, size);<br>  &#125;<br><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>“那自定义的分配器呢？”我听到你在问。</p>
<p>你也可以提供一个接受额外参数的 <code>P::operator new()</code> 重载，如果能找到合适的重载版本，则会在调用时传递左值引用给协程函数的参数。这可以用于将 <code>operator new</code> 与分配器上的 <code>allocate()</code> 方法挂钩，此分配器会作为参数传递给协程函数。</p>
<p>你可能需要做一些额外的操作在分配的内存中复制分配器，由于参数不会传递到对应的 <code>operator delete</code> 中，这样做使你能够在调用对应的 <code>operator delete</code> 时引用这个分配器。这是因为参数存储在协程帧中，到调用 <code>operator delete</code> 时它们已经被释放了。</p>
<p>例如，你可以实现一个在协程帧之后额外分配内存的 <code>operator new</code>，用这些空间来存储一个分配器的副本，以用于释放协程帧的内存。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ALLOCATOR&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">my_promise_type</span><br>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... ARGS&gt;</span><br><span class="hljs-function">  <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> sz, std::<span class="hljs-type">allocator_arg_t</span>, ALLOCATOR&amp; allocator, ARGS&amp;... args)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-comment">// 将 sz 对齐到 ALLOCATOR 对齐方式的下一个倍数</span><br>    std::<span class="hljs-type">size_t</span> allocatorOffset =<br>      (sz + <span class="hljs-built_in">alignof</span>(ALLOCATOR) - <span class="hljs-number">1u</span>) &amp; ~(<span class="hljs-built_in">alignof</span>(ALLOCATOR) - <span class="hljs-number">1u</span>);<br><br>    <span class="hljs-comment">// 调用分配器来给协程帧分配空间</span><br>    <span class="hljs-type">void</span>* ptr = allocator.<span class="hljs-built_in">allocate</span>(allocatorOffset + <span class="hljs-built_in">sizeof</span>(ALLOCATOR));<br><br>    <span class="hljs-comment">// 复制一个分配器副本（这里假定复制构造函数是 noexcept 的）</span><br>    <span class="hljs-keyword">new</span> (((<span class="hljs-type">char</span>*)ptr) + allocatorOffset) <span class="hljs-built_in">ALLOCATOR</span>(allocator);<br><br>    <span class="hljs-keyword">return</span> ptr;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr, std::<span class="hljs-type">size_t</span> sz)</span></span><br><span class="hljs-function">  </span>&#123;<br>    std::<span class="hljs-type">size_t</span> allocatorOffset =<br>      (sz + <span class="hljs-built_in">alignof</span>(ALLOCATOR) - <span class="hljs-number">1u</span>) &amp; ~(<span class="hljs-built_in">alignof</span>(ALLOCATOR) - <span class="hljs-number">1u</span>);<br><br>    ALLOCATOR&amp; allocator = *<span class="hljs-built_in">reinterpret_cast</span>&lt;ALLOCATOR*&gt;(<br>      ((<span class="hljs-type">char</span>*)ptr) + allocatorOffset);<br><br>    <span class="hljs-comment">// 先将分配器移动到局部变量，这样它就不会在下面释放自己的内存了</span><br>    <span class="hljs-comment">// 这里假定移动构造函数是 noexcept 的</span><br>    ALLOCATOR allocatorCopy = std::<span class="hljs-built_in">move</span>(allocator);<br><br>    <span class="hljs-comment">// 但是不要忘记在协程帧内析构分配器对象</span><br>    allocator.~<span class="hljs-built_in">ALLOCATOR</span>();<br><br>    <span class="hljs-comment">// 最后，释放分配器的内存</span><br>    allocatorCopy.<span class="hljs-built_in">deallocate</span>(ptr, allocatorOffset + <span class="hljs-built_in">sizeof</span>(ALLOCATOR));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>你需要特化 <code>coroutine_traits</code> 类，来连接这个用于协程的自定义 <code>my_promise_type</code>，这个协程传递 <code>std::allocator_arg</code> 作为第一个参数（关于 <code>coroutine_traits</code> 下方章节会有更详细的介绍）。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">namespace</span> std::experimental<br>&#123;<br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ALLOCATOR, <span class="hljs-keyword">typename</span>... ARGS&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">coroutine_traits</span>&lt;my_return_type, std::<span class="hljs-type">allocator_arg_t</span>, ALLOCATOR, ARGS...&gt;<br>  &#123;<br>    <span class="hljs-keyword">using</span> promise_type = my_promise_type&lt;ALLOCATOR&gt;;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意，即使你自定义了协程的内存分配策略，<strong>编译器仍然允许省略调用你的内存分配器</strong>。</p>
<h3 id="将参数复制到协程帧">将参数复制到协程帧</h3>
<p>协程需要将原始调用者传递到协程函数中的任意参数都复制到协程帧，这样在协程挂起时这些参数仍然有效。</p>
<p>如果参数是值传递到协程，那么这些参数就会调用移动构造函数来复制到协程帧。</p>
<p>如果参数是引用传递到协程（无论是左值还是右值），那么只会复制引用到协程帧，而不是其所指向的值。</p>
<p>注意对于那些有平凡析构的参数，如果它在协程中一个可到达的点 <code>&lt;return-to-caller-or-resumer&gt;</code> 之后再也没有引用，那么编译器就可以自由删去这个参数的副本。</p>
<p>当传递引用参数到协程中会包含很多陷阱：你不能在协程的生命周期中依赖这个引用也保持有效。一些普通函数的通用技术，例如完美转发和万能引用，如果用于协程则会导致代码产生未定义行为。如果你想获取更多信息，Toby Allsopp 就此话题写了一篇<a target="_blank" rel="noopener" href="https://toby-allsopp.github.io/2017/04/22/coroutines-reference-params.html">很棒的文章</a>可供参考。</p>
<p>如果任意参数的复制/移动构造函数抛出异常，那么任意已构造的参数将会析构，协程帧会释放，异常会传播回调用者。</p>
<h3 id="构造承诺对象">构造承诺对象</h3>
<p>一旦所有参数都复制到协程帧中，协程就会构造一个承诺对象。</p>
<p>在构造承诺对象之前先复制参数，是为了允许承诺对象在其构造函数中访问复制后的参数。</p>
<p>首先，编译器会检查构造函数是否存在重载，该重载可以接受每个复制参数的左值引用。如果编译器找到这样的重载，那么编译器就会生成对这个重载构造函数的调用。如果没找到这样的重载，那么编译器就会退回调用承诺类型的默认构造函数。</p>
<p>注意，允许承诺对象构造函数“偷看”参数是 Coroutines TS 最近变更的一项功能，在 2018 年的杰克逊维尔市会议上为 <a target="_blank" rel="noopener" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4723.pdf">N4723</a> 所采纳。有关提案请参见 <a target="_blank" rel="noopener" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0914r1.html">P0914R1</a>。因此，有些 Clang 或 MSVC 的旧版本编译器可能不支持该功能。</p>
<p>如果承诺对象构造函数抛出异常，则在传播到调用方之前，参数副本会析构，并在栈展开时释放协程帧。</p>
<h3 id="获取返回对象">获取返回对象</h3>
<p>协程对承诺对象做的第一件事，就是通过调用 <code>promise.get_return_object()</code> 来获取 <code>return-object</code>。</p>
<p><code>return-object</code> 是当协程第一次挂起时，或者协程运行完成之后执行返回给调用者时，协程函数所返回给调用者的一个值。</p>
<p>你可以将控制流程考虑成这样（很粗略）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 假设这是个编译器生成的协程帧结构，里面保存着协程所需的所有状态。</span><br><span class="hljs-comment">// 它的构造函数接受参数副本并默认构造一个承诺对象。</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">coroutine_frame</span> &#123; ... &#125;;<br><br><span class="hljs-function">T <span class="hljs-title">some_coroutine</span><span class="hljs-params">(P param)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">auto</span>* f = <span class="hljs-keyword">new</span> <span class="hljs-built_in">coroutine_frame</span>(std::forward&lt;P&gt;(param));<br><br>  <span class="hljs-keyword">auto</span> returnObject = f-&gt;promise.<span class="hljs-built_in">get_return_object</span>();<br><br>  <span class="hljs-comment">// 通过恢复协程来执行。</span><br>  <span class="hljs-comment">// 当协程到达第一个挂起点或运行完成时，这个调用会返回。</span><br>  coroutine_handle&lt;<span class="hljs-keyword">decltype</span>(f-&gt;promise)&gt;::<span class="hljs-built_in">from_promise</span>(f-&gt;promise).<span class="hljs-built_in">resume</span>();<br><br>  <span class="hljs-comment">// 接着这个返回对象会返回给调用者。</span><br>  <span class="hljs-keyword">return</span> returnObject;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意我们需要在启动协程体之前获取返回对象，这是由于协程帧（以及承诺对象）可能会在对 <code>coroutine_handle::resume()</code> 的调用返回之前就销毁，这可能发生在此线程或其它线程。所以在启动协程体之前调用 <code>get_return_object()</code> 可能会不安全。</p>
<h3 id="初始挂起点-initial-suspend-point">初始挂起点（initial-suspend point）</h3>
<p>一旦协程帧初始化完成，并且获取到返回对象，那么协程执行的下一件事就是执行 <code>co_await promise.initial_suspend();</code> 语句。</p>
<p>这允许 <code>promise_type</code> 的作者来控制协程会在源代码中出现的协程体代码执行之前挂起，还是立即开始执行协程体的代码。</p>
<p>如果协程在初始挂起点挂起，那么之后当你选择在协程的 <code>coroutine_handle</code> 上调用 <code>resume()</code> 或 <code>destroy()</code> 之时，协程便会恢复或销毁。</p>
<p><code>co_await promise.initial_suspend()</code> 表达式的结果会被丢弃，所以 awaiter 上的 <code>await_resume()</code> 方法的实现通常需要返回 <code>void</code>。</p>
<p>值得注意的是，这些语句存在于 <code>try/block</code> 块之外，以保护协程的其余部分（如果你忘记了协程体的内容，就请回到协程体的定义部分）。这意味着任何从 <code>co_await promise.initial_suspend()</code> 抛出的异常，在到达 <code>&lt;return-to-caller-or-resumer&gt;</code> 之前，会在销毁协程帧和返回对象之后抛回给协程的调用者。</p>
<p>如果你的 <code>return-object</code> 拥有 RAII 语义，会在析构时销毁协程帧，那么请注意这一点。如果是这种情况，那么你需要确保 <code>co_await promise.initial_suspend()</code> 为 <code>noexcept</code> 来避免对协程帧的双重释放。</p>
<blockquote>
<p>注意有提案提出要微调语义，令 <code>co_await promise.initial_suspend()</code> 表达式的全部或部分内容位于协程体的 <code>try/block</code> 块之内，由此在协程最终确定之前，这里的确切语义可能会发生变化。</p>
</blockquote>
<p>对于许多类型的协程，<code>initial_suspend()</code> 方法可能会返回 <code>std::experimental::suspend_always</code>（如果操作延迟启动）或 <code>std::experimental::suspend_never</code>（如果操作立即启动），这些都是 <code>noexcept</code> 的 awaitable，所以这通常不是问题。</p>
<h3 id="返回给调用者">返回给调用者</h3>
<p>当协程函数到达它的第一个 <code>&lt;return-to-caller-or-resumer&gt;</code> 点（或者协程完成执行时没有到达这种点），那么 <code>get_return_object()</code> 调用中所返回的 <code>return-object</code> 会返回给协程的调用者。</p>
<p>注意 <code>return-object</code> 不必和协程函数的返回类型具有相同类型。如果有必要，会执行一个从 <code>return-object</code> 到协程返回类型的隐式转换。</p>
<blockquote>
<p>注意 Clang 的协程实现（截至5.0）会推迟执行这个转换，直到 <code>return-object</code> 从一个协程的调用中返回。然而 MSVC 的实现，截至 2017 Update 3，会在调用 <code>get_return_object()</code> 之后立即进行转换。尽管 Coroutines TS 并未明确说明预期行为，但我相信 MSVC 已有计划改变其实现，以使其表现得更像 Clang 的实现，因为这可以实现一些<a target="_blank" rel="noopener" href="https://github.com/toby-allsopp/coroutine_monad">有趣的用例</a>。</p>
</blockquote>
<h3 id="使用-co-return-从协程返回">使用 co_return 从协程返回</h3>
<p>当协程到达一个 <code>co_return</code> 语句，它会转换为调用 <code>promise.return_void()</code> 或 <code>promise.return_value(&lt;expr&gt;)</code>，接着是 <code>goto FinalSuspend;</code>。</p>
<p>转换的规则如下：</p>
<ul>
<li><code>co_return;</code><br>
-&gt; <code>promise.return_void();</code></li>
<li><code>co_return &lt;expr&gt;;</code><br>
-&gt; <code>&lt;expr&gt;; promise.return_void();</code> 如果 <code>&lt;expr&gt;</code> 拥有类型 <code>void</code><br>
-&gt; <code>promise.return_value(&lt;expr&gt;);</code> 如果 <code>&lt;expr&gt;</code> 没有类型 <code>void</code></li>
</ul>
<p>随后执行的 <code>goto FinalSuspend;</code> 会导致所有具有自动存储期的局部变量以构造相反的顺序析构，之后评估 <code>co_await promise.final_suspend();</code>。</p>
<p>注意，如果执行跑出了协程的末尾而没有 <code>co_return</code> 语句，那么这就和协程体末尾有一个 <code>co_return;</code> 相同。在这种情况下，如果 <code>promise_type</code> 没有 <code>return_void()</code>，那么此行为未定义。</p>
<p>如果 <code>&lt;expr&gt;</code> 求值时，或调用 <code>promise.return_void()</code> 或 <code>promise.return_value()</code> 时抛出异常，那么异常仍然会传播给 <code>promise.unhandled_exception()</code>（见下文）。</p>
<h3 id="处理从协程体传播出去的异常">处理从协程体传播出去的异常</h3>
<p>如果异常传播出协程体，那么就会被 <code>catch</code> 块中调用的 <code>promise.unhandled_exception()</code> 方法所捕获。</p>
<p>这个方法的实现往往会调用 <code>std::current_exception()</code> 来捕获异常的副本，将其保存以便在之后不同上下文中重新抛出。</p>
<p>或者，可以实现为执行 <code>throw;</code> 语句立即将异常重新抛出。可以参考 <a target="_blank" rel="noopener" href="https://github.com/facebook/folly/blob/4af3040b4c2192818a413bad35f7a6cc5846ed0b/folly/Optional.h#L587">folly::Optional</a>。并且，这样做会（很有可能——见下文）导致协程帧立即销毁，并将异常传播到调用者/恢复器。这可能会为某些假设/要求 <code>coroutine_handle::resume()</code> 为 <code>noexcept</code> 的抽象带来问题，因此你通常只能在完全控制谁/什么调用 <code>resume()</code> 时，才能够使用这种方法。</p>
<p>注意到当前的 <a target="_blank" rel="noopener" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4736.pdf">Coroutines TS</a> 对于在调用 <code>unhandled_exception()</code> 中重新抛出异常的预期行为描述得<a target="_blank" rel="noopener" href="https://github.com/GorNishanov/coroutines-ts/issues/17">不是很清楚</a>（或者就此而言，对于任何 try 块之外的逻辑抛出的异常）。</p>
<p>我现在对这种措辞的解释是，如果控制离开了协程体，无论异常传播出 <code>co_await promise.initial_suspend()</code>、<code>promise.unhandled_exception()</code> 还是 <code>co_await promise.final_suspend()</code>，或者通过 <code>co_await p.final_suspend()</code> 协程同步执行完成，协程帧都会在执行返回给调用者/恢复器之前自动地销毁。但是，这种解释也有它自己的问题。</p>
<p>协程规范的未来版本有望能阐明这种情况。不过在此之前，我会避免从 <code>initial_suspend()</code>、<code>final_suspend()</code> 或 <code>unhandled_exception()</code> 中抛出异常。敬请期待。</p>
<h3 id="最终挂起点-final-suspend-point">最终挂起点（final-suspend point）</h3>
<p>当执行离开了协程体的用户定义部分，而且通过调用 <code>return_void()</code>、<code>return_value()</code> 或 <code>unhandled_exception()</code> 捕获了结果，并且任意局部变量都析构了，此时协程将执行返回给调用者/恢复器之前，还有能力执行一些附加逻辑。</p>
<p>协程会执行 <code>co_await promise.final_suspend();</code> 语句。</p>
<p>这允许协程执行一些逻辑，例如发布结果、发出完成信号或者恢复继续执行。也会允许协程在执行完成并且协程帧销毁之前，可以选择立即挂起。</p>
<p>注意对 <code>final_suspend</code> 点挂起的协程调用 <code>resume()</code> 是未定义行为。在这里，你能对这个挂起的协程所做的唯一的事情就是 <code>destroy()</code> 它。</p>
<p>Gor Nishanov 认为，这种限制的理由是，减少协程需要表示的挂起状态的数量，潜在地减少所需分支的数量，这有助于为编译器提供若干优化机会。</p>
<p>注意，虽然允许在 <code>final_suspend</code> 点处不挂起协程，但<strong>还是建议你尽可能在 <code>final_suspend</code> 处挂起协程</strong>。这是因为强制在协程外面对协程调用 <code>.destroy()</code>（通常从一些 RAII 对象的析构函数中），能让编译器更容易确定协程帧的生命周期是否嵌套在调用者内部。这反过来又使编译器更有可能省略协程帧的内存分配。</p>
<h3 id="编译器如何选择承诺类型">编译器如何选择承诺类型</h3>
<p>所以现在让我们来看一下，编译器是如何决定用于给定协程的承诺对象类型的。</p>
<p>可以通过使用 <code>std::coroutine_traits</code> 类，根据协程的签名，来决定承诺对象的类型（这里原文使用的是 <code>std::experimental::coroutine_traits</code> 类，本译文将所有 <code>std::experimental</code> 命名空间的内容都移到 <code>std</code> 命名空间下，下同。——译注）。</p>
<p>如果你的协程函数签名如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">task&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">foo</span><span class="hljs-params">(std::string x, <span class="hljs-type">bool</span> flag)</span></span>;<br></code></pre></td></tr></table></figure>
<p>那么编译器会将返回类型和参数类型作为模板参数传递给 <code>coroutine_traits</code>，来推断协程的承诺类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typename</span> coroutine_traits&lt;task&lt;<span class="hljs-type">float</span>&gt;, std::string, <span class="hljs-type">bool</span>&gt;::promise_type;<br></code></pre></td></tr></table></figure>
<p>如果函数是一个非静态成员函数，那么类类型会作为模板的第二个参数传递给 <code>coroutine_traits</code>。注意如果你的方法重载了右值引用版本，那么第二个模板参数也会是一个右值引用。</p>
<p>例如，如果你有如下方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">task&lt;<span class="hljs-type">void</span>&gt; <span class="hljs-title">my_class::method1</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">task&lt;foo&gt; <span class="hljs-title">my_class::method2</span><span class="hljs-params">()</span> &amp;&amp;</span>;<br></code></pre></td></tr></table></figure>
<p>那么编译器会使用下列承诺类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// method1 承诺类型</span><br><span class="hljs-keyword">typename</span> coroutine_traits&lt;task&lt;<span class="hljs-type">void</span>&gt;, <span class="hljs-type">const</span> my_class&amp;, <span class="hljs-type">int</span>&gt;::promise_type;<br><br><span class="hljs-comment">// method2 承诺类型</span><br><span class="hljs-keyword">typename</span> coroutine_traits&lt;task&lt;foo&gt;, my_class&amp;&amp;&gt;::promise_type;<br></code></pre></td></tr></table></figure>
<p><code>coroutine_traits</code> 模板的默认定义是通过寻找返回类型嵌套定义的 <code>promise_type</code> 来定义 <code>promise_type</code>，即一些这样的内容（但使用了一些额外的 SFINAE 魔法，如果没定义 <code>RET::promise_type</code> 那么就不定义 <code>promise_type</code>）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">namespace</span> std<br>&#123;<br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> RET, <span class="hljs-keyword">typename</span>... ARGS&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">coroutine_traits</span>&lt;RET, ARGS...&gt;<br>  &#123;<br>    <span class="hljs-keyword">using</span> promise_type = <span class="hljs-keyword">typename</span> RET::promise_type;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>所以对于你控制的协程返回类型，你可以只在你的类中定义一个嵌套的 <code>promise_type</code> ，来让编译器使用该类型作为协程的承诺对象的类型。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task</span><br>&#123;<br>  <span class="hljs-keyword">using</span> promise_type = task_promise&lt;T&gt;;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>但是，对于你不能控制的协程返回类型，你可以指定 <code>coroutine_traits</code> 来定义承诺类型，而不需要改变这个类型。</p>
<p>例如，定义返回 <code>std::optional&lt;T&gt;</code> 的用于协程的承诺类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">namespace</span> std<br>&#123;<br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... ARGS&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">coroutine_traits</span>&lt;std::optional&lt;T&gt;, ARGS...&gt;<br>  &#123;<br>    <span class="hljs-keyword">using</span> promise_type = optional_promise&lt;T&gt;;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="识别特定的协程激活帧">识别特定的协程激活帧</h3>
<p>当你调用一个协程函数，就会创建一个协程帧。为了恢复相关的协程，或销毁协程帧，你需要一些方法来识别或者引用特定的协程帧。</p>
<p>Coroutines TS 为此提供的机制是 <code>coroutine_handle</code> 类型。</p>
<p>这个类型的（缩略的）接口如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">namespace</span> std<br>&#123;<br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Promise = <span class="hljs-type">void</span>&gt;<br>  <span class="hljs-keyword">struct</span> coroutine_handle;<br><br>  <span class="hljs-comment">// 擦除类型的协程句柄（coroutine handle）。可以引用任何类型的协程。</span><br>  <span class="hljs-comment">// 不允许访问承诺对象。</span><br>  <span class="hljs-keyword">template</span>&lt;&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">coroutine_handle</span>&lt;<span class="hljs-type">void</span>&gt;<br>  &#123;<br>    <span class="hljs-comment">// 构造空句柄。</span><br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">coroutine_handle</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 为了传递到 C 风格的互操作函数而转换为/转换自 void*</span><br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">void</span>* <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> coroutine_handle <span class="hljs-title">from_address</span><span class="hljs-params">(<span class="hljs-type">void</span>* addr)</span></span>;<br><br>    <span class="hljs-comment">// 查询句柄是否非空。</span><br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;<br><br>    <span class="hljs-comment">// 查询协程是否在 final_suspend 点挂起。</span><br>    <span class="hljs-comment">// 如果协程当前没挂起那么就是未定义行为。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">done</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// 恢复/销毁挂起的协程。</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resume</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>;<br>  &#125;;<br><br>  <span class="hljs-comment">// 已知承诺对象的协程句柄。</span><br>  <span class="hljs-comment">// 模板参数必须完全与协程的承诺类型一致。</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Promise&gt;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">coroutine_handle</span> : coroutine_handle&lt;&gt;<br>  &#123;<br>    <span class="hljs-keyword">using</span> coroutine_handle&lt;&gt;::coroutine_handle;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> coroutine_handle <span class="hljs-title">from_address</span><span class="hljs-params">(<span class="hljs-type">void</span>* addr)</span></span>;<br><br>    <span class="hljs-comment">// 访问协程的承诺对象。</span><br>    <span class="hljs-function">Promise&amp; <span class="hljs-title">promise</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// 你可以从承诺对象重新构建协程句柄。</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> coroutine_handle <span class="hljs-title">from_promise</span><span class="hljs-params">(Promise&amp; promise)</span></span>;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>你可以用以下两种方法获取协程的 <code>coroutine_handle</code>：</p>
<ol>
<li>在 <code>co_await</code> 表达式期间传递到 <code>await_suspend()</code> 方法。</li>
<li>如果你引用了一个协程的承诺对象，你可以使用 <code>coroutine_handle&lt;Promise&gt;::from_promise()</code> 重新构建 <code>coroutine_handle</code>。</li>
</ol>
<p>协程在使用 <code>co_await</code> 表达式挂起在 <code>&lt;suspend-point&gt;</code> 之后，这个等待中的协程的 <code>coroutine_handle</code> 就会传递到 awaiter 的 <code>await_suspend()</code> 方法中。你可以将 <code>coroutine_handle</code> 视为一个在<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Continuation-passing_style">持续传递风格（continuation-passing style）</a>的调用中，协程持续的一个代表。</p>
<p>注意 <code>coroutine_handle</code> <strong>不是</strong>一个 RAII 对象。你必须手动调用 <code>.destroy()</code> 来销毁协程帧，并释放其资源。可将其视为等同于用来管理内存的 <code>void*</code>。这是出于性能考虑：将其作为 RAII 对象会对协程添加额外的开销，例如对引用计数的需要。</p>
<p>你通常需要使用更高级的类型来为协程提供 RAII 语义，例如 <a target="_blank" rel="noopener" href="https://github.com/lewissbaker/cppcoro">cppcoro</a>（作者写的库——译注）中提供的那样，或者你编写自己的高级类型，来为你的协程类型封装协程帧的生命周期。</p>
<h3 id="自定义-co-await-的行为">自定义 co_await 的行为</h3>
<p>对于每个出现在协程体中的 <code>co_await</code> 表达式，承诺类型可选择定制其行为。</p>
<p>通过简单地在承诺类型上定义一个 <code>await_transform()</code> 方法，编译器会将之后协程体中出现的每一个 <code>co_await &lt;expr&gt;</code> 转换为 <code>co_await promise.await_transform(&lt;expr&gt;)</code>。</p>
<p>这有许多重要且强大的用途：</p>
<p><strong>它允许你启用通常无法等待的等待类型。</strong></p>
<p>例如，一个拥有 <code>std::optional&lt;T&gt;</code> 返回值的协程承诺类型，可能会提供一个 <code>await_transform()</code> 重载，该重载接收一个 <code>std::optional&lt;U&gt;</code> 并返回一个可等待类型（awaitable type），该类型要么返回类型 <code>U</code> 的值，要么在等待值包含 <code>std::nullopt</code> 时挂起协程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">optional_promise</span><br>&#123;<br>  ...<br><br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function">  <span class="hljs-keyword">auto</span> <span class="hljs-title">await_transform</span><span class="hljs-params">(std::optional&lt;U&gt;&amp; value)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">awaiter</span><br>    &#123;<br>      std::optional&lt;U&gt;&amp; value;<br>    <span class="hljs-keyword">public</span>:<br>      <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">awaiter</span><span class="hljs-params">(std::optional&lt;U&gt;&amp; x)</span> <span class="hljs-keyword">noexcept</span> : value(x) &#123;</span>&#125;<br>      <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> value.<span class="hljs-built_in">has_value</span>(); &#125;<br>      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(std::experimental::coroutine_handle&lt;&gt;)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;&#125;<br>      <span class="hljs-function">U&amp; <span class="hljs-title">await_resume</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> *value; &#125;<br>    &#125;;<br>    <span class="hljs-keyword">return</span> awaiter&#123; value &#125;;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>通过将 <code>await_transform</code> 的某个重载声明为删除，来禁止等待特定类型。</strong></p>
<p>例如，<code>std::generator&lt;T&gt;</code> 返回类型的承诺类型声明了一个删除的 <code>await_transform()</code> 模板成员函数，这个函数能接收任何值。这基本就禁止了在这个协程中使用 <code>co_await</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">generator_promise</span><br>&#123;<br>  ...<br><br>  <span class="hljs-comment">// 禁止在这个类型的写成中任意对 co_await 的使用。</span><br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function">  std::suspend_never <span class="hljs-title">await_transform</span><span class="hljs-params">(U&amp;&amp;)</span> </span>= <span class="hljs-keyword">delete</span>;<br><br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>它允许你调整和改变普通可等待值的行为。</strong></p>
<p>例如，你可以定义一种协程类型，通过 <code>resume_on</code> 操作符（见 <code>cppcoro::resume_on()</code>）对可等待内容进行包装，确保协程总是从关联执行器上的每个 <code>co_await</code> 表达式上恢复。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Executor&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">executor_task_promise</span><br>&#123;<br>  Executor executor;<br><br><span class="hljs-keyword">public</span>:<br><br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Awaitable&gt;</span><br><span class="hljs-function">  <span class="hljs-keyword">auto</span> <span class="hljs-title">await_transform</span><span class="hljs-params">(Awaitable&amp;&amp; awaitable)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">using</span> cppcoro::resume_on;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">resume_on</span>(<span class="hljs-keyword">this</span>-&gt;executor, std::forward&lt;Awaitable&gt;(awaitable));<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>关于 <code>await_transform()</code>，最后需要注意的是，如果承诺类型定义了 <em>任何</em> <code>await_transform()</code> 成员，就会让编译器将 <em>所有</em> <code>co_await</code> 表达式转换为调用 <code>promise.await_transform()</code>。这意味着如果你只想定制某些类型的 <code>co_await</code> 的行为，你还是需要提供一个仅转发参数的 <code>await_transform()</code> 的回退重载。</p>
<h3 id="定制-co-yield-的行为">定制 co_yield 的行为</h3>
<p>最后一件你可以在承诺类型中定制的事情是 <code>co_yield</code> 关键字的行为。</p>
<p>如果 <code>co_yield</code> 关键字出现在协程中，那么编译器会将表达式 <code>co_yield &lt;expr&gt;</code> 转换为 <code>co_await promise.yield_value(&lt;expr&gt;)</code>。因此这个承诺类型可以通过在承诺对象上定义一个或多个 <code>yield_value()</code> 方法，来定制 <code>co_yield</code> 关键字的行为。</p>
<p>注意到，不同于 <code>await_transform</code>，如果承诺类型不定义 <code>yield_value()</code> 方法，那么 <code>co_yield</code> 是没有默认行为的。所以承诺类型需要通过声明一个删除的 <code>await_transform()</code> 来显式禁止 <code>co_await</code>，而支持 <code>co_yield</code> 则需要选择支持此关键字。</p>
<p>具有 <code>yield_value()</code> 方法的承诺类型的一个典型的例子，就是 <code>generator&lt;T&gt;</code> 类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">generator_promise</span><br>&#123;<br>  T* valuePtr;<br><span class="hljs-keyword">public</span>:<br>  ...<br><br>  std::<span class="hljs-function">experimental::suspend_always <span class="hljs-title">yield_value</span><span class="hljs-params">(T&amp; value)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-comment">// 存储迭代值的地址，并返回一个 awaitable 会导致协程在 co_yield 表达式处挂起。</span><br>    <span class="hljs-comment">// 调用无论是 generator&lt;T&gt;::begin() 还是 generator&lt;T&gt;::iterator::operator++() 中的</span><br>    <span class="hljs-comment">// coroutine_handle&lt;&gt;::resume() 都会让执行返回。</span><br>    valuePtr = std::<span class="hljs-built_in">addressof</span>(value);<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="总结">总结</h2>
<p>在这篇文章中，我介绍了编译器将函数编译为协程时对其进行的各种转换。</p>
<p>希望这篇文章能帮你理解，如何通过定义不同的你自己的承诺类型，来定制不同类型协程的行为。协程机制里有许多可活动部件，因此你可以使用许多不同的方法来定制它们的行为。</p>
<p>但是，还有一个编译器执行的重要转换我目前还没有说到——将协程体转换为状态机。不过，这篇文章已经太长了，所以我想要推迟到下一篇文章中进行解释。敬请期待。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ferociousmagikarp.github.io">Ferocious Magikarp</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ferociousmagikarp.github.io/posts/43da13b0/">https://ferociousmagikarp.github.io/posts/43da13b0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://ferociousmagikarp.github.io" target="_blank">鲤鱼王的记录小宇宙</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E5%8D%8F%E7%A8%8B/">协程</a><a class="post-meta__tags" href="/tags/%E5%8D%9A%E5%AE%A2%E7%BF%BB%E8%AF%91/">博客翻译</a></div><div class="post-share"><div class="social-share" data-image="/image/head.png"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/a397fa9e/" title="《线性代数应该这样学》·第二章·C"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">《线性代数应该这样学》·第二章·C</div></div><div class="info-2"><div class="info-item-1">维数。</div></div></div></a><a class="pagination-related" href="/posts/5d84b368/" title="《线性代数应该这样学》·第三章·A"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">《线性代数应该这样学》·第三章·A</div></div><div class="info-2"><div class="info-item-1">向量空间的线性映射。</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related no-desc" href="/posts/a2a9fa5f/" title="C++协程理论"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-19</div><div class="info-item-2">C++协程理论</div></div></div></a><a class="pagination-related" href="/posts/1405587/" title="C++协程：理解co_await操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-17</div><div class="info-item-2">C++协程：理解co_await操作</div></div><div class="info-2"><div class="info-item-1">原文来自 C++ Coroutines: Understanding operator co_await。</div></div></div></a><a class="pagination-related" href="/posts/e90d03dc/" title="32位整数位交错的速度能做到多快"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-16</div><div class="info-item-2">32位整数位交错的速度能做到多快</div></div><div class="info-2"><div class="info-item-1">原文来自 How fast can you bit-interleave 32-bit integers 以及 How fast can you bit-interleave 32-bit integers? (SIMD edition)。</div></div></div></a><a class="pagination-related no-desc" href="/posts/fc667c96/" title="C++17语言特性记录"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-30</div><div class="info-item-2">C++17语言特性记录</div></div></div></a><a class="pagination-related no-desc" href="/posts/19f1ba17/" title="C++20语言特性记录"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-01</div><div class="info-item-2">C++20语言特性记录</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Ferocious Magikarp</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/FerociousMagikarp"><i class="fab fa-github"></i><span>个人没啥价值的主页</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="toc-text">协程概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BF%E8%AF%BA%E5%AF%B9%E8%B1%A1-promise-objects"><span class="toc-text">承诺对象（Promise objects）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%8D%8F%E7%A8%8B%E5%B8%A7"><span class="toc-text">分配协程帧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E7%A8%8B%E5%B8%A7%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">自定义协程帧内存分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E5%8F%82%E6%95%B0%E5%A4%8D%E5%88%B6%E5%88%B0%E5%8D%8F%E7%A8%8B%E5%B8%A7"><span class="toc-text">将参数复制到协程帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%89%BF%E8%AF%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">构造承诺对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1"><span class="toc-text">获取返回对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E6%8C%82%E8%B5%B7%E7%82%B9-initial-suspend-point"><span class="toc-text">初始挂起点（initial-suspend point）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%BB%99%E8%B0%83%E7%94%A8%E8%80%85"><span class="toc-text">返回给调用者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-co-return-%E4%BB%8E%E5%8D%8F%E7%A8%8B%E8%BF%94%E5%9B%9E"><span class="toc-text">使用 co_return 从协程返回</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E4%BB%8E%E5%8D%8F%E7%A8%8B%E4%BD%93%E4%BC%A0%E6%92%AD%E5%87%BA%E5%8E%BB%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-text">处理从协程体传播出去的异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E6%8C%82%E8%B5%B7%E7%82%B9-final-suspend-point"><span class="toc-text">最终挂起点（final-suspend point）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%89%BF%E8%AF%BA%E7%B1%BB%E5%9E%8B"><span class="toc-text">编译器如何选择承诺类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%86%E5%88%AB%E7%89%B9%E5%AE%9A%E7%9A%84%E5%8D%8F%E7%A8%8B%E6%BF%80%E6%B4%BB%E5%B8%A7"><span class="toc-text">识别特定的协程激活帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-co-await-%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-text">自定义 co_await 的行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6-co-yield-%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-text">定制 co_yield 的行为</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Ferocious Magikarp</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>